package Task1;



/*3 задание
Условие
Ограничение времени
5 секунд
Ограничение памяти
1024 МБ
Пете дали мультимножество ﻿A﻿ размера ﻿n﻿, содержащее натуральные число.
 Теперь Петя хочет по этому мультимножеству сгенерировать последовательность ﻿x_{0}, x_{1}, x_{n}x

Правило для генерации ﻿x{i}
следующее: Сначала Петя выбирает положительное ﻿x{0}
Затем Петя должен взять все элементы ﻿AA﻿ ровно по одному разу (заметьте, Петин порядок может
 отличаться от изначального порядка элементов в А). Назовем
текущий элемент множества ﻿A﻿ как ﻿a﻿. Если до этого Петя взял ﻿k﻿ элементов ﻿A﻿, то ﻿x{k+1}=x{k}^{2}-a
Петя расстроится, если какой-то элемент последовательности ﻿x{i} станет меньше нуля.
 Найдите минимальный подходящий ﻿x{0}
﻿, который может выбрать Петя, чтобы у него была возможность сконструировать последовательность и
не расстроиться.
Например, если ﻿x{0}=3 и ﻿A={3,4}, то можно сгенерировать такую последовательность:

﻿a=4, x{1}=9-4=5
a=3, x{2}=25-3=22
Итоговая последовательность ﻿3﻿, ﻿5﻿, ﻿22﻿ не расстроит Петю. При этом ﻿ x0 = 2
 не подойдет (можно самостоятельно проверить, почему), значит, число ﻿3﻿ является ответом.

Формат входных данных

В первой строке дается целое число ﻿(1 <= n <= 10^{5})
В следующей строке через пробел вводится ﻿n﻿ целых чисел ﻿a{1}, a_{i},  a_{n}
 (1<= a_i <= 10^{18}﻿﻿-−﻿ мультимножество ﻿A﻿.

Обратите внимание, что для ввода чисел вам понадобится 64-битный тип данных.
Формат выходных данных

Выведите одно число ﻿-−﻿ такой минимальный ﻿x{0}, с которым Петя сможет проделать все необходимые
операции и не расстроиться.

Примеры данных
Пример 1
2
3 4
вывод:
3
Пример 2
5
1 1 1 1 1
вывод:
2
Пример 3
3
2 1 100
вывод:
3
Решение*/

import java.util.*;
public class Task3 {


    private static final Scanner sc;

    static {
        sc = new Scanner(System.in);
    }
    public static void main(String[] args) {
   Long[] number=getData(1);
   Long[] numbers=getData(Math.toIntExact(number[0]));

   long x0=1;//начинаем с положительного

   Set<Long> treeset=new TreeSet<Long>(Arrays.asList(numbers));
   ArrayList<Long> arrayList=new ArrayList(treeset);
       
       // System.out.println(treeset);

        int i=0; //переменная для итерации
        long temp=x0;
        for (; i <treeset.size() ;) {

         long result= (long) Math.pow(temp,2)-arrayList.get(i);
         if (result<=0){
             i=0;
             temp=++x0;
         }
         if(result>0){
             ++i;
            temp=result;
         }
        }
        System.out.println(x0);

    }


    private static Long[] getData(int n) {
        if (sc.hasNext()) {
            String input = sc.nextLine();
            String[] inputValues = input.split(" ");
            Long[] userData = new Long[n];
            for (int i = 0; i < inputValues.length; i++) {
                userData[i] = Long.parseLong(inputValues[i]);
            }
            return userData;
        }
        return null;
    }
}
